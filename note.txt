[ Frontend (React + Tailwind + ShadCN + Redux Toolkit) ]

         â†“  Axios (interceptors, requÃªtes HTTPS)

[ Backend (Node + Express + Middlewares + Auth + Stripe) ]

         â†“  Mongoose (ODM)

[ Database (MongoDB - Atlas / Compass) ]




MVC : 
[ Front ] : requÃªte HTTP (GET, POST, PUT, PATCH, DELETE..)
        â†“ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ Routes ] : dÃ©finit lâ€™URL + choisit le contrÃ´leur
        â†“
[ Controller ] : Contient la logique mÃ©tier
        â†“
[ Model ] : GÃ¨re les donnÃ©es (BDD via Mongoose)
        â†“
RÃ©ponse HTTP (JSON)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ Front ] : Affiche la rÃ©ponse (UI)




Express (req / res / next()) :
[ Utilisateur ]
        â†“  
      req = requÃªte HTTP = infos envoyÃ©es (body, params, query, headersâ€¦)
        â†“
[ Middleware / ContrÃ´leur Express (req, res, next) ]
        â†“
      next() â†’ Passe au middleware / contrÃ´leur suivant
        â†“
      res = rÃ©ponse HTTP (status, JSON, texteâ€¦)
        â†“
[ Utilisateur ]




JWT : 
[ Utilisateur ]
     â†“ (login : email + mot de passe)
[ Serveur Auth (Node / Express) ]
     â†“
VÃ©rifie le user en BDD (bcrypt.compare)
     â†“
CrÃ©e un JWT signÃ© (id, email, rÃ´le...) + expiresIn
     â†“
Renvoie le token au front
--------------------------------------------
[ Front (React) ]
     â†“
Stocke le token (ex: localStorage ou cookies)
     â†“
Envoie le token dans chaque requÃªte (headers: Authorization: Bearer <token>)
--------------------------------------------
[ Serveur API protÃ©gÃ©e ]
     â†“
ğŸ” VÃ©rifie le token avec jwt.verify()
     â†“
âœ… Si valide â†’ autorise la requÃªte
âŒ Si expirÃ© / invalide â†’ renvoie 401 (Unauthorized)




Stripe :
[ Front ]
   â”‚  POST /pay { order, items }
   â–¼
[ Back ]
   â”‚  â†’ CrÃ©e une Checkout Session Stripe (infos paiement + success_url + cancel_url)
   â”‚  â†’ ReÃ§oit session.url et le renvoie au Front
   â–¼
[ Front ]
   â”‚  â†’ Redirige lâ€™utilisateur vers session.url
   â–¼
[ Stripe Checkout ]
   â”‚  â†’ Affiche la page â†’ lâ€™utilisateur paie ou annule
   â–¼
[ Stripe renvoie automatiquement vers ]
   â”œâ”€ âœ… success_url  (paiement rÃ©ussi)
   â””â”€ âŒ cancel_url   (paiement annulÃ©)



   
XSS (Cross-Site Scripting) :
1. Sans xss-clean
[ Client malveillant ] â†’ envoie du code JS cachÃ© dans un champ (formulaire, commentaire, etc.)
     â†“
[ Serveur ] â†’ enregistre ce code sans le filtrer
     â†“
[ Autre utilisateur ] â†’ âš ï¸ charge la page â†’ le code JS sâ€™exÃ©cute dans son navigateur !
     â†“
RÃ©sultat : Le pirate peut voler des cookies, des tokens JWT, ou rediriger lâ€™utilisateur vers un faux site.

2. Avec xss-clean
[ Client ] â†’ formulaire : "comment": "<script>hack()</script>"
        â†“
[ Serveur ] â†’ reÃ§oit la requÃªte
        â†“
xss-clean intercepte et nettoie : "<script>" â†’ "&lt;script&gt;"
        â†“
[ Serveur ] â†’ enregistre ou renvoie les donnÃ©es propres
        â†“
[ Navigateur ] â†’ nâ€™exÃ©cute pas de script malveillant




Helmet : 
[ RequÃªte navigateur ]
        â†“
[ Express + Helmet ] â†’ Helmet ajoute des headers de sÃ©curitÃ© dans les rÃ©ponses HTTP par ex :
        â†“
    X-Frame-Options: SAMEORIGIN
    X-Content-Type-Options: nosniff
    Strict-Transport-Security: max-age=15552000 ...
        â†“
[ Navigateur ] â†’ lit et applique ces rÃ¨gles de sÃ©curitÃ©




express-mongo-sanitize :
[ RequÃªte du client ] â†’ injecte des opÃ©rateurs MongoDB ($, .) pour manipuler/contourner les requÃªtes de bdd
     â†“
  { "$gt": "", "user": "admin" }
     â†“
[ express-mongo-sanitize ] â†’ supprime/neutralise les clÃ©s contenant '$' ou '.' dans req.body / query / params
     â†“
  { "user": "admin" }
     â†“
[ RequÃªte MongoDB sÃ©curisÃ©e ]




MongoDB Atlas
Organisation
â”‚
â”œâ”€ Projet 1
â”‚   â”œâ”€ Cluster A
â”‚   â”‚   â”œâ”€ Base de donnÃ©es X
â”‚   â”‚   â”‚   â”œâ”€ Collection 1 (utilisateurs)
â”‚   â”‚   â”‚   â”‚   â””â”€ Document : { nom: "Alice", email: "alice@mail.com" }
â”‚   â”‚   â”‚   â””â”€ Collection 2 (commandes)
â”‚   â”‚   â””â”€ Base de donnÃ©es Y
â”‚   â””â”€ Cluster B (Backup / RÃ©plica / Sauvegarde)
â”‚
â””â”€ Projet 2
    â””â”€ Cluster C (DÃ©veloppement / Test)









DEPLOYER : 

1. MongoDB Atlas
- CrÃ©er un projet (Aventurix)-> crÃ©er un cluster (aws)
- Dans Database Users : crÃ©er un utilisateur de base de donnÃ©es (Built-in Role: Read and write to any database) (aventurix-admin)
Copier user + mdp, coller quelque part pour utiliser plus tard
- Dans Network Access â†’ Add IP Address â†’ Choisir : Allow Access From Anywhere
Pourquoi Autoriser toutes les IP ? : On autorise 0.0.0.0/0 dans MongoDB Atlas parce que les plateformes comme Vercel nâ€™ont pas dâ€™IP fixe.
La sÃ©curitÃ© reste assurÃ©e grÃ¢ce aux identifiants de lâ€™utilisateur MongoDB.
MongoDB Compass
- Atlas : venir dans Cluster â†’ Connect â†’ Compass â†’ Copy the connection string, then open MongoDB Compass
- Compass : New Connection â†’ coller le lien + changer mdp â†’ Save & Connect (cette Ã©tape, on se connect en distanciel Ã  la bdd qui est sur cloud)
- Compass : Create Database (Collection Name name = aventurix, Collection Name = advisers) (cette Ã©tape, on fait comme dÃ©jÃ  fait sur localhost)
- Compass : importer des donnÃ©es par collection
- Atlas : recheck les collections sur Atlas dans Cluster â†’ Browse Collections



2. Vercel : se prÃ©parer le code backend avant de dÃ©ployer sur Vercel :
- api/index.js : crÃ©er dossier api â†’ copier index.js dedans. 
Modifier index.js : changer ./ vers ../, ajouter la ligne app.set("trust proxy", 1);, remplacer app.listen(..) par module.exports = app;
index.js (racine) : sert Ã  lancer le serveur uniquement en local
api/index.js : sert Ã  exporter l'app pour Vercel (sans app.listen())
- public/index.html : ajouter index.html dans public
- vercel.json : ajouter ce fichier Ã  la racine du projet. e fichier dit Ã  Vercel : Â« Quand quelquâ€™un appelle une route, envoie tout vers /api, oÃ¹ se trouve mon backend. Â» (ex: /login â†’ /api/login)
- database.js : modifier mongoUriAtlas (DB_USER / DB_PWD sera dÃ©finies sur Vercel)

app.set("trust proxy", 1); ???
[ Navigateur ]
   â”‚
   â”‚ envoie une requÃªte HTTPS
   â†“ 
[ Vercel ] (hÃ©berge + sÃ©curise)
   â”‚
   â”‚ transmet la requÃªte en HTTP interne + dit "câ€™Ã©tait bien HTTPS" 
   â†“
[ Serveur Express ]
   â”‚
   â†“
[ MongoDB Atlas ]

app.set("trust proxy", 1)
â†’ Dit Ã  Express : "La connexion Ã©tait sÃ©curisÃ©e, tu peux faire confiance."

Vercel = une plateforme qui hÃ©berge l'application web. ConcrÃ¨tement, Vercel fait 3 choses :
+ hÃ©berge le site: le code est envoyÃ© sur leurs serveurs â†’ le site devient accessible via une URL.
+ gÃ¨re le HTTPS automatiquement : Pas besoin dâ€™acheter un certificat SSL. Pas besoin de configurer la sÃ©curitÃ© nous-mÃªme.
+ joue le rÃ´le de â€œproxyâ€ entre le client et le serveur Express. Vercel est un intermÃ©diaire qui : reÃ§oit la requÃªte, ajoute des infos utiles (comme lâ€™IP rÃ©elle du client), puis transmet au serveur Express.

- Vercel transmet la requÃªte au serveur Express. La connexion entre Vercel et Express nâ€™a pas besoin dâ€™Ãªtre HTTPS. Elle se fait en HTTP interne (câ€™est normal et sÃ©curisÃ© â†’ câ€™est un rÃ©seau interne)
- Maintenant, Express reÃ§oit HTTP (interne). Et Express pourrait se tromper : "Ah ! Câ€™est du HTTP â†’ donc pas sÃ©curisÃ© â†’ je bloque les cookies secure et je considÃ¨re lâ€™IP que je vois comme Ã©tant la vraie (alors que câ€™est celle du proxy)"
- Pourquoi trust proxy ? Parce que Vercel DONNE lâ€™info Ã  Express dans un header spÃ©cial : X-Forwarded-Proto: https
Mais Express ne fait pas confiance par dÃ©faut. Alors on Ã©crit : app.set("trust proxy", 1);
Ce qui veut dire : "La connexion Ã©tait sÃ©curisÃ©e, tu peux faire confiance."



