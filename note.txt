[ Frontend (React + Tailwind + ShadCN + Redux Toolkit) ]

         â†“  Axios (interceptors, requÃªtes HTTPS)

[ Backend (Node + Express + Middlewares + Auth + Stripe) ]

         â†“  Mongoose (ODM)

[ Database (MongoDB - Atlas / Compass) ]




MVC : 
[ Front ] : requÃªte HTTP (GET, POST, PUT, PATCH, DELETE..)
        â†“ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ Routes ] : dÃ©finit lâ€™URL + choisit le contrÃ´leur
        â†“
[ Controller ] : Contient la logique mÃ©tier
        â†“
[ Model ] : GÃ¨re les donnÃ©es (BDD via Mongoose)
        â†“
RÃ©ponse HTTP (JSON)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[ Front ] : Affiche la rÃ©ponse (UI)




Express (req / res / next()) :
[ Utilisateur ]
        â†“  
      req = requÃªte HTTP = infos envoyÃ©es (body, params, query, headersâ€¦)
        â†“
[ Middleware / ContrÃ´leur Express (req, res, next) ]
        â†“
      next() â†’ Passe au middleware / contrÃ´leur suivant
        â†“
      res = rÃ©ponse HTTP (status, JSON, texteâ€¦)
        â†“
[ Utilisateur ]




JWT : 
[ Utilisateur ]
     â†“ (login : email + mot de passe)
[ Serveur Auth (Node / Express) ]
     â†“
VÃ©rifie le user en BDD (bcrypt.compare)
     â†“
CrÃ©e un JWT signÃ© (id, email, rÃ´le...) + expiresIn
     â†“
Renvoie le token au front
--------------------------------------------
[ Front (React) ]
     â†“
Stocke le token (ex: localStorage ou cookies)
     â†“
Envoie le token dans chaque requÃªte (headers: Authorization: Bearer <token>)
--------------------------------------------
[ Serveur API protÃ©gÃ©e ]
     â†“
ğŸ” VÃ©rifie le token avec jwt.verify()
     â†“
âœ… Si valide â†’ autorise la requÃªte
âŒ Si expirÃ© / invalide â†’ renvoie 401 (Unauthorized)




Stripe :
[ Front ]
   â”‚  POST /pay { order, items }
   â–¼
[ Back ]
   â”‚  â†’ CrÃ©e une Checkout Session Stripe (infos paiement + success_url + cancel_url)
   â”‚  â†’ ReÃ§oit session.url et le renvoie au Front
   â–¼
[ Front ]
   â”‚  â†’ Redirige lâ€™utilisateur vers session.url
   â–¼
[ Stripe Checkout ]
   â”‚  â†’ Affiche la page â†’ lâ€™utilisateur paie ou annule
   â–¼
[ Stripe renvoie automatiquement vers ]
   â”œâ”€ âœ… success_url  (paiement rÃ©ussi)
   â””â”€ âŒ cancel_url   (paiement annulÃ©)



   
XSS (Cross-Site Scripting) :
1. Sans xss-clean
[ Client malveillant ] â†’ envoie du code JS cachÃ© dans un champ (formulaire, commentaire, etc.)
     â†“
[ Serveur ] â†’ enregistre ce code sans le filtrer
     â†“
[ Autre utilisateur ] â†’ âš ï¸ charge la page â†’ le code JS sâ€™exÃ©cute dans son navigateur !
     â†“
RÃ©sultat : Le pirate peut voler des cookies, des tokens JWT, ou rediriger lâ€™utilisateur vers un faux site.

2. Avec xss-clean
[ Client ] â†’ formulaire : "comment": "<script>hack()</script>"
        â†“
[ Serveur ] â†’ reÃ§oit la requÃªte
        â†“
xss-clean intercepte et nettoie : "<script>" â†’ "&lt;script&gt;"
        â†“
[ Serveur ] â†’ enregistre ou renvoie les donnÃ©es propres
        â†“
[ Navigateur ] â†’ nâ€™exÃ©cute pas de script malveillant




Helmet : 
[ RequÃªte navigateur ]
        â†“
[ Express + Helmet ] â†’ Helmet ajoute des headers de sÃ©curitÃ© dans les rÃ©ponses HTTP par ex :
        â†“
    X-Frame-Options: SAMEORIGIN
    X-Content-Type-Options: nosniff
    Strict-Transport-Security: max-age=15552000 ...
        â†“
[ Navigateur ] â†’ lit et applique ces rÃ¨gles de sÃ©curitÃ©




express-mongo-sanitize :
[ RequÃªte du client ] â†’ injecte des opÃ©rateurs MongoDB ($, .) pour manipuler/contourner les requÃªtes de bdd
     â†“
  { "$gt": "", "user": "admin" }
     â†“
[ express-mongo-sanitize ] â†’ supprime/neutralise les clÃ©s contenant '$' ou '.' dans req.body / query / params
     â†“
  { "user": "admin" }
     â†“
[ RequÃªte MongoDB sÃ©curisÃ©e ]




Vercel : se prÃ©parer le code backend avant de dÃ©ployer sur Vercel :
1. /api/index.js : crÃ©er dossier api â†’ copier index.js dedans. 
Modifier index.js : changer ./ vers ../, ajouter app.set("trust proxy", 1);
2. /public/index.html : ajouter index.html dans public
3. /vercel.json : ajouter ce fichier Ã  la racine du projet. e fichier dit Ã  Vercel : Â« Quand quelquâ€™un appelle une route, envoie tout vers /api, oÃ¹ se trouve mon backend. Â» (ex: /login â†’ /api/login)
4. /database.js : modifier mongoUriAtlas (DB_USER / DB_PWD sera dÃ©finies sur Vercel)

app.set("trust proxy", 1); ???
[ Navigateur ]
   â”‚
   â”‚ envoie une requÃªte HTTPS
   â†“ 
[ Vercel ] (hÃ©berge + sÃ©curise)
   â”‚
   â”‚ transmet la requÃªte en HTTP interne + dit "câ€™Ã©tait bien HTTPS" 
   â†“
[ Serveur Express ]
   â”‚
   â†“
[ MongoDB Atlas ]

app.set("trust proxy", 1)
â†’ Dit Ã  Express : "La connexion Ã©tait sÃ©curisÃ©e, tu peux faire confiance."

Vercel = une plateforme qui hÃ©berge l'application web. ConcrÃ¨tement, Vercel fait 3 choses :
+ hÃ©berge le site: le code est envoyÃ© sur leurs serveurs â†’ le site devient accessible via une URL.
+ gÃ¨re le HTTPS automatiquement : Pas besoin dâ€™acheter un certificat SSL. Pas besoin de configurer la sÃ©curitÃ© nous-mÃªme.
+ joue le rÃ´le de â€œproxyâ€ entre le client et le serveur Express. Vercel est un intermÃ©diaire qui : reÃ§oit la requÃªte, ajoute des infos utiles (comme lâ€™IP rÃ©elle du client), puis transmet au serveur Express.

- Vercel transmet la requÃªte au serveur Express. La connexion entre Vercel et Express nâ€™a pas besoin dâ€™Ãªtre HTTPS. Elle se fait en HTTP interne (câ€™est normal et sÃ©curisÃ© â†’ câ€™est un rÃ©seau interne)
- Maintenant, Express reÃ§oit HTTP (interne). Et Express pourrait se tromper : "Ah ! Câ€™est du HTTP â†’ donc pas sÃ©curisÃ© â†’ je bloque les cookies secure et je considÃ¨re lâ€™IP que je vois comme Ã©tant la vraie (alors que câ€™est celle du proxy)"
- Pourquoi trust proxy ? Parce que Vercel DONNE lâ€™info Ã  Express dans un header spÃ©cial : X-Forwarded-Proto: https
Mais Express ne fait pas confiance par dÃ©faut. Alors on Ã©crit : app.set("trust proxy", 1);
Ce qui veut dire : "La connexion Ã©tait sÃ©curisÃ©e, tu peux faire confiance."



